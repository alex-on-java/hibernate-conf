## План рассказа
1. Hibernate как абстракция доступа к БД.
    1. Контролирование запросов на выборку генерируемых Hibernate. 
        1. При написании тестов нужно контролировать количество запросов в БД проектируемому при помощи логгеров запросов. Показать пользу такого решения: меняем связи, тесты проходят, но запросы увеличиваются. С ассертом на кол-во запросов мы контролиуем это.
        2. Варианты связывания сущностей и влияние связи на количество запросов. 
            1. fetch = LAZY - Hibernate совершит запрос при обращении к полю. Минусы: много запросов и возможность LazyInitializationException.
            2. @EntityGraph. Минус: Неочевидно, что будет содержаться в объекте, т.к. одни поля будут загружены, а другие нет.
            3. Создание DTO в JPQL запросе. Минусы: многословность, нет озможности использовать генерацию запросов по названию метода.
            4. Spring-data Projection, появившийся с 1.10+.
    2. Избегание излишней связанности сущностей.
        1. Описание проблем @ManyToMany. Неявность связующей таблицы, сложность создания связи,  невозможность обращаться к связующей таблице.
        2. Деление доменной модели на независимые сегменты, которые не имеют связи вообще или она единственная. Строгий контроль за связями междуу сегментами. Связи в виде ID вместо связуемого обекта объекта. Обеспечение низкой связанности кода невозможно при сильной связанности доменной модели.
        3. Связующее поля используются только Hibernate, а не кодом. Для передачи сущность и ее связей плиентскому коду используется DTO/интерфейс.
    3. Обновление и удаление записей.
        1. Избегание практики загрузил-обновил-сохранил. Использовать только в сложной логике, когда прямой апдейт будет многословен или сложнособираем.
        2. Использование Entity reference для добавления связи (метод getOne(id)) вместо загрузки сущности целиком.
        3. Для удаления связей нельзя использовать удаление из списка.
2. Разделение слоев приложения и влияния Hibernate, не допуская его выше уровня сервиса. Изолирование сущностей от внешнего АПИ.
    1. Проблема в потере контроля над слоем данных, т.к. сервис может изменить сущность. При этом возможны следующие неприятности:
        1. Сущность может быть обновлена автоматически, если она не выходит из транзакции.
        2. Если сущность выходит из транзакци, то необходимо обратно приаттачивать ее к сессии для сохранения.
    2. Сущность сильно завязана на структуру БД, но вынесение структуры на клиентский проиводит к проблемам в обратной совместимости и сложности изменения слоя модели отдельно от других.
        1. При передаче сущности клиенту, структура объектов последнего будет завязана на структуру БД, что не всегда оптимально. Также необходимо следить за включением/исключением полей в ответы клиенту в целях безопасности. Решение - использование DTO и Mapstruct для более легкого мэппинга.

## Сценарий
Легенда: Новый сотрудник, обучавшийся Hibernate в инете приходит в компанию и начинает работу над новым проектом таск-трекером. Дальнейший сценарий складывается из реализации  юзер-стори.
1. Задача "Вход в приложение". Для упрощения - без пароля и фреймворков типа Spring-security. На этом этапе позникает простой CRUD для пользователя.
2. Задача "Добавление сущностей Проект и Задача". На этом этапе появляется простая связь - таск-проект
3. Задача "Список задач в проекте". Джуниор добавляет связь в проект @OneToMany List<Task> в сущность Project. Решение плохо тем, что:
    - нет возможности сделать постраничное разбиение
    - при загрузке списка Задач загружаем Проект
    Решение грузим такски репозиторием по ID 
4. Задача: "Хранить Создателя и исполнителя задачи". На это этапе возникает два @ManyToOne, которые имеют default fetch = EAGER. Теперь ползователи грузятся вместе со списком задач. Джуниор это замечает и изменяет fetch на LAZY.
5. Баг: "Появился LazyInitializationException", т.к. происходит сериализация в JSON. Джуниор не обращается к Сеньору и находит флаг hibernate.enable_lazy_load_no_trans. Лишние запросы все равно есть из-за сериализации, но теперь еще сильнее используются соединения к БД.
6. Задача: "Список всех пользователей, у которых есть задачи". Джуниор решает загрузить все Задачи, получить Пользователей и положить в Set<>. 
    
    Когда Сеньор видит это - хватается за голову. Показывется сколько лишних запросов и предлагает написать выгрузку через запрос. Решение - Джуниор пишет JPQL
7. Задача: "Комментарии к задачам". Задачи должны отображаться с комментариями. *Обсудить проблему экспоуза доменной модели*
8. Задача: "В списке задач выводить количество комментариев по ним". Решение Джуниора - List<Task>.size() при преобразовании в DTO. Опять много запросов. Решение Сеньора JPQL - запрос с DTO b GroupBy
9. Задача: "Реализовать точку для получения пользователя с задачей". Первое решение - fetch = EAGER.
Однако, в другом месте одновременная загрузка не нужна. В этот момент джуниор уходит в отпуск, а в его отсутствие Сеньор возвращает LAZY и добавляет EntityGraph. Джуниор возвращается и для другой задачи использает метод, который грузит еще и юзеров. Решение - использование DTO. Рассказ про projectons
10. Задача: "Очистить проект". Джуниор загружает все Задачи и использует delete(List) - огромное количество запросов на delete. Правильное решение - запрос на удаление. 
11. Задача: "Перевести таск с одного пользователя на другого". Появляется лишний запрос на выборку. Проблема load-change-save. Решение - использовать modify. В случае массовой операции - количество лишних запросов 2n
12. **ManyToMany Проблема создания связи. Нужно загрузить одну сущность со всем спискои и добавить ссылку на новый объект + помимо селекта хибер делает delete всего списка и insert заново. Решение - создать сущность-связь**
13. **что-то про автоматическое обновление сущности.**